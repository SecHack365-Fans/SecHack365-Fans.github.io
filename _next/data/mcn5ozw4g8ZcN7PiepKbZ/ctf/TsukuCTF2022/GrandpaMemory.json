{"pageProps":{"postData":{"id":"GrandpaMemory","contentHtml":"# GrandpaMemory\n\n今回の問題は、Research UNIX version1 上でコンパイルされた PDP-11/20 の実行ファイルを人力で逆アセンブルしてみるという問題となる。\n\n## PDP エンディアン\n\nPDP-11 では特殊なエンディアンの方式が採用されていた。これは 32 ビットワードを構成する 2 つの 16 ビットワードはビッグエンディアンで格納され、16 ビットワードはリトルエンディアンで格納がされる。\n\n詳しくは以下のリンク先を見てほしい。\n\nhttps://ja.wikipedia.org/wiki/PDP-11\n\nただし、今回は 32 ビットのデータを扱っていないため、リトルエンディアンだけ抑えておけば問題ない。\n\n## Research UNIX version1 のヘッダー\n\n重要なのは、ヘッダーが終わった 12 バイト目からプログラムが実行されるということである。\nヘッダーに関して詳しく知りたい場合、以下のリンク先を見てほしい。\n\nhttps://www.bell-labs.com/usr/dmr/www/man51.pdf\n\n## PDP-11 の命令\n\nエンディアンと同様に以下のリンク先が詳しい。\n\n[PDP エンディアン](https://ja.wikipedia.org/wiki/PDP-11#PDP%E3%82%A8%E3%83%B3%E3%83%87%E3%82%A3%E3%82%A2%E3%83%B3)\n\n## 解き方\n\n### PDP-11 のバイナリであることを知る\n\n実行ファイルに file コマンドを行ってみると以下の出力が見られる。\n\n```bash\n> file a.out\na.out: PDP-11 old overlay\n```\n\nここから PDP-11 のバイナリであることがわかる。\n\n### フラグがある場所を知る\n\n実行ファイルに cat コマンドを行ってみると以下のような出力が見られると思う。\n\n```bash\n> cat a.out\n4\n\n�\n�\n�\n �\n  �\n   �\n    �\n     B`�passwd is in R2\n```\n\npasswd is in R2 という文字列から最終的な計算結果は R2 レジスタに入るとわかる。\n\n### 2 進数に変換して出力する\n\nxxd コマンドを利用し、2 進数でダンプを行う。\n\n```bash\n>  xxd -g 1 -b a.out\n00000000: 00000101 00000001 00110100 00000000 00000000 00000000  ..4...\n00000006: 00000000 00000000 00000000 00000000 00000000 00000000  ......\n0000000c: 00000001 00001010 00000010 00001010 10000001 00001010  ......\n00000012: 10000010 00001010 11000001 00001100 11000001 00001100  ......\n00000018: 11000001 00001100 11000001 00001100 11000010 00001100  ......\n0000001e: 01000010 01100000 11111111 00000001 01110000 01100001  B`..pa\n00000024: 01110011 01110011 01110111 01100100 00100000 01101001  sswd i\n0000002a: 01110011 00100000 01101001 01101110 00100000 01010010  s in R\n00000030: 00110010 00100000 00000000 00001010                    2 ..\n```\n\nこのバイナリを読み解いていくのがこの問題となる。\n\n### 実行ファイルを読み解いていく\n\nまず、ヘッダーを取り除く。前述の通りヘッダは 12 バイトであり、プログラムはヘッダ直後から実行されていくためである。\nヘッダーを取り除くと以下の様になる。(アドレスと ascii コードも取り除いている)\n\n```txt\n00000001 00001010 00000010 00001010 10000001 00001010\n10000010 00001010 11000001 00001100 11000001 00001100\n11000001 00001100 11000001 00001100 11000010 00001100\n01000010 01100000 11111111 00000001\n```\n\n基本的に 16 ビットワードを１命令として扱うため、16 ビットずつ見ていこう。\n\n#### 00000001\\_00001010\n\n以下二進数はリトルエンディアンとして 1 バイト逆に置き換えたものである。\n\n```txt\n0000101000 000001\n```\n\n上位 4 ビットに値がないことから 2 オペンランド命令でないことがわかる。\nまた、11 ビット目が 0 でないことから無条件分岐命令でないこともわかる。\n\n要するにこれは、1 オペランド命令となる。1 オペランド命令は上位 10 ビットが命令コードとなるので 0000101000 が命令となる。参考リンク先では、8 進数で命令コードが表現されているので 0000101000 を 8 進数に置き換えると 50 である。50 は CLR 命令であるので、レジスタを 0 クリアしていることがわかる。レジスタは 2~0 ビットで指定するので R1 を 0 クリアしていることがわかる。\n\n```txt\nCLR R1\n```\n\n#### 00000010\\_00001010\n\n```txt\n0000101000 000010\n```\n\n前の命令と同じ命令コードなので CLR 命令であることがわかる。また、レジスタは 10 であるので R2 を示していることがわかる。\n\n```txt\nCLR R2\n```\n\n#### 10000001 00001010\n\n```txt\n0000101010 000001\n```\n\nCLR 命令と同様に１オペランド命令である。0000101010 は 8 進数で表すと 52 であり、INC 命令であることがわかる。またレジスタは R1 を示していることがわかる。\n\n```txt\nINC R1\n```\n\n#### 10000010\\_00001010\n\n```txt\n0000101010 000010\n```\n\n前の命令と同じく INC 命令である。レジスタは 10 であるため R2 である。\n\n```txt\nINC R2\n```\n\n#### 11000001\\_00001100\n\n```txt\n0000110011 000001\n```\n\nこの命令も 1 オペランド命令である。11011 を 8 進数にすると 63 であり、ASR 命令であるとわかる。またレジスタは R1 である。\n\n```txt\nASR R1\n```\n\nまた、この命令が 4 命令続く。\n\n#### 11000010\\_00001100\n\n```txt\n0000110011 000010\n```\n\nこの命令は前の命令と同じく ASR 命令であり、レジスタが 10 であることから R2 となる。\n\n```txt\nASR R2\n```\n\n#### 01000010\\_01100000\n\n```txt\n0110 000001 000010\n```\n\nこの命令の場合、11 ビット目が 0 であり、最上位ビットから 4 ビットにデータがあることから 2 オペランド命令であることがわかる。2 オペランド命令は最上位ビットから 4 ビットが命令コードを表すので、0110 が命令コードとなる。0110 を 8 進数に変換すると、6 となる。よって ADD 命令であることがわかる。また、レジスタは 8/~6 ビット目と 2/~0 ビット目が source と destination を示すので、source が R1 であり、destination が R2 であることがわかる。\n\n```txt\nADD R1, R2\n```\n\n#### 11111111\\_00000001\n\n```txt\n00000001 11111111\n```\n\nこの命令の場合、11 ビット目が 0 かつ上位 7 ビットに命令コードがないため条件分岐命令であることがわかる。その場合、参考先のように命令を解釈すると、0000000100000000 となり 4XX であるとわかる。また、11111111 は無条件分岐のオフセットは符号付整数であるため、2 の補数表現からマイナスであることがわかる。よって無限ループとなっている。\n\n```txt\nBR -1(実際はラベル)\n```\n\n#### 結果\n\n今回元となった機械語のプログラムは以下になる。\n\n```asm\n/ tukuCTF GrandpaMemory\n   clr r1\n   clr r2\n   inc r1\n   inc r2\n   asl r1\n   asl r1\n   asl r1\n   asl r1\n   asl r2\n   add r1, r2\n1:\n   br 1b\n\n\nhint:\n    <passwd is in R2 \\0\\n>\n```\n\nまず、r1 と r2 レジスタを 0 クリアする。その後、r1,r2 をインクリメントし r1=1,r2=1 とする。また、asl は左シフトで値を 2 倍にする命令である。よって、計算結果は R2=18 となる。\n\n## フラグ\n\nTsukuCTF22{18}\n","title":"GrandpaMemory","description":"実行ファイルを読んでみる。","author":"Wagahaiha_toto","genre":"Rev","solver":17,"point":498}},"__N_SSG":true}